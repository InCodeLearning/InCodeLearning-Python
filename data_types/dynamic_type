import sys
# 1.variable VS object
a = 3        # Assign a name to an object

# 1. Create an object to represent the value 3.
# 2. Create the variable a, if it does not yet exist.
# 3. Link the variable a to the new object 3.
#
# variables and objects are stored in different parts of memory and are associated by links
# (the link is shown as a pointer in the figure).
# Variables always link to objects and never to other variables,
# but larger objects may link to other objects (for instance, a list object has links to the objects it contains).
#
# - Variables are entries in a system table, with spaces for links to objects.
#
# - Objects are pieces of allocated memory, with enough space to represent the values
#
# - for which they stand.
#
# - References are automatically followed pointers from variables to objects.

# 2.Types Live with Objects, Not Variables

x = 42
x = 'shrubbery'
# Reclaim 42 now (unless referenced elsewhere)
x = 3.1415  # Reclaim 'shrubbery' now
x = [1, 2, 3] # Reclaim 3.1415 now

# object is garbage collected like java when no reference found.
# Python accomplishes this feat by keeping a counter in every object
# that keeps track of the number of references currently pointing to that object.

#
# The most immediately tangible benefit of garbage collection is that it means you can use objects liberally without
# ever needing to allocate or free up space in your script. Python will clean up unused space for you
# as your program runs.
#
# 3.

L1 = [2, 3, 4]  # A mutable object
L2 = L1  # Make a reference to the same object
L1[0] = 24  # An in-place change

print L1
# [24, 3, 4]  # L1 is different
print L2
# [24, 3, 4]  # But so is L2!

L1 = [2, 3, 4]
L2 = L1[:]   # Make a copy of L1 (or list(L1), copy.copy(L1), etc.)
L1[0] = 24

print L1
# [24, 3, 4]
print L2     # L2 is not changed
# [2, 3, 4]

L = [1, 2, 3]
M = [1, 2, 3]
print L==M
print L is M      # Different objects

X = 42
Y = 42
print X == Y
print X is Y      # Same object anyhow: caching at work!

# True
# False
# True
# True

# Because Python caches and reuses small integers and small strings, as mentioned earlier,
# the object 42 here is probably not literally reclaimed; instead, it will likely remain in a system
# table to be reused the next time you generate a 42 in your code. Most kinds of objects,
# though, are reclaimed immediately when they are no longer referenced; for those that are not,
# the caching mechanism is irrelevant to your code.
#
# you can always ask Python how many references there are to an object:
print sys.getrefcount(1)
